#import "book-style.typ": *
#import "@preview/theorion:0.3.3": *
#import "@preview/commute:0.3.0": node, arr, commutative-diagram
#import cosmos.rainbow: *
#show: show-theorion

#let vdash = math.class("normal", math.tack.r)
#let Vdash = math.class("normal", math.tack.r.double)

= 一阶逻辑
一阶逻辑同样有符号，字母，合式公式，推理规则，公理等概念。我们先介绍语法。

== 一阶理论
一阶逻辑的符号包括：括号 $()$，字母，命题逻辑的 $not,->$，全称量词 $forall$，还有下面四种符号：
- 变量：带下标的 $x$： $x_1, x_2, dots, x_n, dots$；
- 常量：带下标的 $a$：$a_1, a_2, dots, a_n, dots$；
- 谓词字母：$A_k^n$，这里 $n$ 和 $k$ 是正整数；
- 函数字母：$f_k^n$，这里 $n$ 和 $k$ 是正整数。
在谓词字母和函数字母中，上标 $n$ 表示参数的个数，下标用来区分有相同个数的参数的不同的函数或者谓词字母。
另外，为了方便，经常用 $x,y,z$ 等最后几个字母来表示变量 $x_1,x_2,x_3$。
经常用 $a,b,c$ 等前几个字母表示常量 $a_1, a_2, a_3$。

现在定义*项(term)*和*原子公式(atomic formula)*：
+ 变量和常量是项；
+ 如果 $f_k^n$ 是函数字母，$t_1,t_2,dots, t_n$ 是项，那么字符串 $f_k^n (t_1, dots, t_n)$ 也是项；
+ 所有的项都通过上面两个步骤得到。
把谓词应用在项上面得到原子公式，也就是说如果 $A_k^n$ 是谓词字母，$t_1, t_2, dots, t_n$ 是项，
那么字符串 $A_k^n (t_1,dots,t_n)$ 是原子公式，下面也把原子公式称为谓词。

#note-box[
  从直观语义上来说，谓词反映了项与项之间的关系或者具有的性质，它是一种表达其内部的变量是否具有某种性质的断言，
  当变量变化时这些变量是否具有性质也会跟着变化。对于二元谓词来说，比如 $<=$ 就是序理论中的二元谓词，$a <= b$ 就断言 $a$ 是否小于 $b$。
  也就是说谓词 $A_1^2(a,b)$ 表示 $a<=b$ 的判断，当成立时这个谓词就是真，否则就是假。
  
  函数就是从一个项得到另一个项的办法。在运算中，$+$ 就是一种二元函数，它从 $x$ 和 $y$ 得到 $x + y$。
]

于是我们合式公式定义为：
+ 原子公式是合式公式；
+ 如果 $cal(B), cal(C)$ 是合式公式，$y$ 是变量，那么 $(not cal(B)), (cal(B) -> cal(C))$ 和 $((forall y) cal(B))$ 是合式公式；
+ 所有合式公式都通过上面两个步骤得到。

在 $((forall y) cal(B))$ 当中，$cal(B)$ 称为量词 $(forall y)$ 的*作用域(scope)*。注意 $cal(B)$ 并不需要真的包含 $y$，
如果在这种情况，我们把 $((forall y) cal(B))$ 视为 $cal(B)$，可以当做一条推理规则。

表达式 $(cal(B) and cal(C)), (cal(B) or cal(C))$ 和 $(cal(B) <-> cal(C))$ 的定义与前面相同。
而存在量词 $exists$ 定义为全称量词的否定，也就是说
#nonum-equation[$
      ((exists x) cal(B)) "    表示    " (not((forall x)(not cal(B))))
$]

在通常的优先级约定下，可以省略括号，把括号的省略当做一条推理规则。

公式 $cal(B)$ 中的一个变量 $x$ 所占据的位置称为*约束占位(bound occurrence)*，
指的是 $x$ 出现在量词 $(forall x)$ 或者这个量词的作用域当中，
否则就说 $x$ 是*自由占位(free occurrence)*。

#example[
  + $A_1^2(x_1, x_2)$
  + $A_1^2(x_1, x_2) -> (forall x_1) A_1^1(x_1)$
  + $(forall x_1)( A_1^2(x_1,x_2) -> (forall x_1) A_1^1(x_1))$
  + $(exists x_1) A_1^2(x_1,x_2)$
  这里 1 当中的两个变量的占位都是自由的。2 当中第一个 $x_1$ 的占位是自由占位，第二个和第三个 $x_1$ 在约束占位里。
  3 当中所有的 $x_1$ 都在约束占位里。4 当中两个 $x_1$ 在约束占位中，注意 $exists$ 是 $forall$ 的否定。
]

一个变量 $x$ 称为*自由变量*或者*约束变量*指的是它在一个自由占位或者约束占位中。因此一个变量可能同时是自由变量和约束变量。

假设 $cal(B)$ 是公式，$t$ 是项，那么公式和项当中有多个变量，设 $x_i$ 是 $cal(B)$ 中出现的变量，$x_j$ 是 $t$ 中出现的变量。
如果量词 $(forall x_j)$ 的作用域当中如果没有自由变量 $x_i$，那么我们说 $t$ 对 $cal(B)$ 中的 $x_i$ 是自由的。

#example[
  #enum[
    项 $x_2$ 对 $A_1^1 (x_1)$ 中的 $x_1$ 是自由的，因为根本就没有量词；但是对 $(forall x_2)A_1^1 (x_1)$ 不是自由的。
  ][
    项 $f_1^2(x_1,x_3)$ 对 $(forall x_2) A_1^2(x_1,x_2) -> A_1^1(x_1)$ 的 $x_1$ 是自由的，因为量词里没有 $x_1,x_3$；
    但是对 $(exists x_3)(forall x_2) A_1^2(x_1, x_2) -> A_1^1(x_1)$ 的 $x_1$ 不是自由的，
    因为项里面的 $x_3$ 出现在公式的量词里面了。
  ] 
]

显然有：
+ 不包含变量的项对任何公式中的任何变量都是自由的。
+ 如果 $cal(B)$ 当中没有约束变量，则 $t$ 对 $cal(B)$ 中的每个变量都是自由的。
+ $x_i$ 对任意公式中的 $x_i$ 是自由的。
+ 如果 $x_i$ 在 $cal(B)$ 中都是约束变量，则任意项对 $cal(B)$ 中的 $x_i$ 都是自由的。


*一阶理论*是形式理论 $K$：
#enum[
  它的符号与合式公式在本节前面已经定义；
][
  它的公理除了命题演算里的三条逻辑公理，还有下面两条逻辑公理：
  #enum(start: 4, numbering: it => [(A#it)])[
    $(forall x_i)cal(B)(x_i) -> cal(B)(t)$，这里 $cal(B)(x_i)$ 是包含 $x_i$ 的公式，$t$ 是项，并且对 $x_i$ 自由。
    这里要求自由实际上是为了 $t$ 的变量和量词的变量互不干扰。
    注意 $t$ 可以是 $x_i$，于是 $(forall x_i)cal(B)(x_i) -> cal(B)$ 是公理。
  ][
    $(forall x_i)(cal(B) -> cal(C)) -> (cal(B) -> (forall x_i)cal(C))$ 这里 $cal(B)$ 不包含自由变量 $x_i$。
  ]

  以及*真公理(proper axioms)*：真公理随着理论的不同而不同，比如集合论中的 ZFC，群公理，实数公理等。如果一个理论没有真公理，
  则被称为*谓词演算(predicate calculus)*。
][
  它的推理规则除了前面命题演算里的肯定前件 MP以外，还有*一般化(generalization)*：$(forall x_i)cal(B)$ 是 $cal(B)$ 的结论。
]

#example(title: "一阶理论的例子")[
  #enum(numbering: "a.")[
    偏序结构：只有一个谓词 $A_1^2$，没有函数字母和常量。我们用 $x_1 < x_2$ 来代替 $A_1^2(x_1,x_2)$。这个理论具有两条真公理
    + 反反身性：$(forall x_1) not(x_1 < x_1)$
    + 传递性：$(forall x_1)(forall x_2)(forall x_3)(x_1 < x_2 and x_2 < x_3 -> x_1 < x_3)$
  ][
    群理论：有一个谓词 $A_1^2$, 一个函数 $f_1^2$，一个常量 $a_1$。我们用 $t =s$ 来替代 $A_1^2(t,s)$，用 $t dot s$ 来替代 $f_1^2(t,s)$，用 $1$ 来代替 $a_1$。
    这个理论有以下几条真公理：
    + 结合律：$(forall x_1)(forall x_2)(forall x_3)((x_1 dot x_2) dot x_3 = x_1 dot (x_2 dot x_3))$
    + 单位元：$(forall x_1)(1 dot x_1 = x_1 and x_1 dot 1 = x_1)$
    + 逆元：$(forall x_1)(exists x_2)(x_1 dot x_2 = 1 and x_2 dot x_1 = 1)$
    + 等号反身性：$(forall x_1)(x_1 = x_1)$
    + 等号对称性：$(forall x_1)(forall x_2)(x_1 = x_2 -> x_2 = x_1)$
    + 等号传递性：$(forall x_1)(forall x_2)(forall x_3)(x_1 = x_2 and x_2 = x_3 -> x_1 = x_3)$
    + 等号替代性：$(forall x_1)(forall x_2)(forall x_3)(x_2 = x_3 -> x_1 dot x_2 = x_1 dot x_3 and x_2 dot x_1 = x_3 dot x_1)$
  ]
  后面 4 条实际上是等号的性质，后面会介绍带等号的一阶理论，真正的群公理实际上只有前面 3 条。
]

== 一阶理论的模型
命题演算只需要通过真值表就能给出一个模型，但一阶理论要复杂一些。

#definition[
  *一阶语言* $scr(L)$ 包含了一阶理论所需的各种符号，也就是说它具有：
  + 命题演算连接符 $not, ->$ 和全称量词 $forall$。
  + 分隔符，也就是左括号 $($，右括号 $)$，还有逗号。
  + 至多可数多个变量 $x_1, x_2, dots$。
  + 至多可数个常量。
  + 至多可数个函数符号。
  + 至少一个谓词符号。

  $scr(L)$ 还要具有项，它根据前面的办法从 $scr(L)$ 的变量和常量以及函数符号得到。

  $scr(L)$ 还要具有合式公式，根据前面的办法从 $scr(L)$ 的原子公式还有命题连接符以及全称量词得到。
]

由合式公式的构成可以看出，如果没有谓词符号，则没有合式公式。从一阶语言的构成可以看出，它实质上是字符串集合，把某个一阶理论所需要的字符串都囊括进来了，
因此我们通常讨论一个一阶语言上的一阶理论，同一个一阶语言上可以有不同的一阶理论。
一阶语言给出了构建理论的材料，其上的一阶理论是使用这些材料的办法，即所谓材料之间的关系。而一阶语言的诠释，以及进而得到的一阶理论的模型，则给出了理论的含义。

#definition[
  设 $scr(L)$ 是一个一阶语言。它的一个*诠释(interpretation)*由下列部分组成：
  + 非空集合 $D$，称为*诠释域*。
  + 对每个谓词 $A_k^n$，指定一个 $D$ 上的 $n$-元关系 $(A_k^n)^M$，或者说是 $n$-元真值函数（也就是结果为 T 或者 F 的函数）。
  + 对每个函数 $f_k^n$，指定一个 $D$ 上的 $n$-元函数 $(f_k^n)^M$。
  + 对每个常量 $a_i$，指定一个 $D$ 中的元素 $(a_i)^M$。
]

在一个诠释下，就可以讨论一阶语言中的合式公式的真假了。没有自由变量的合式公式称为闭的，或者陈述，代表一个可能为真或者假的命题。
而有自由变量的公式，则可能对 $D$ 中某些元素为真，其他元素为假。

设 $M$ 是 $scr(L)$ 的一个诠释，$D$ 是诠释域。又设 $s$ 是 $D$ 中元素的一个序列 $s_1, s_2, dots$。
首先对 $scr(L)$ 中的项 $t$ 按如下方法指定一个 $D$ 中的元素 $s^*(t)$：
+ 如果 $t$ 是变量 $x_i$，那么 $s^*(t)$ 是 $s_i$。
+ 如果 $t$ 是常量 $a_i$，那么 $s^*(t)$ 是它的诠释 $(a_i)^M$。
+ 如果 $f_k^n$ 是函数，它对应 $D$ 上的 $n$-元函数 $(f_k^n)^M$，以及有项 $t_1, dots, t_n$，
则 $s^*(f_k^n (t_1, dots, t_n))$ 是 $(f_k^n)^M (s^*(t_1), dots, s^*(t_n))$。

因此递归地，每项都可以指定一个 $D$ 中的元素。直觉上来说，$s^*(t)$ 是把 $t$ 中的变量 $x_i$ 都替换为 $s_i$，
把常量 $a_i$ 替换为诠释 $(a_i)^M$，把函数替换为对应的 $n$-元函数然后进行演算得到的项。

现在我们可以做如下递归定义：
+ 若 $cal(B)$ 是原子公式 $A_k^n (t_1, dots, t_n)$，那么序列 $s$ *满足* $cal(B)$ 指的是 $(A_k^n)^M (s^*(t_1), dots, s^*(t_n))$，也就是 $n$-元组 $(s^*(t_1), dots, s^*(t_n))$ 有关系 $(A_k^n)^M$。
+ $s$ 满足 $not cal(B)$ 指的是 $s$ 不满足 $cal(B)$。
+ $s$ 满足 $cal(B) -> cal(C)$ 指的是 $s$ 不满足 $cal(B)$ 或者 $s$ 满足 $cal(C)$ （参考 $->$ 的真值表）。
+ $s$ 满足 $(forall x_i)cal(B)$ 指的是，对任意 $D$ 中的元素 $c$，序列 $s_1,s_2, dots, s_(i-1), c, s_(i+1), dots$ 都满足 $cal(B)$，也就是替换 $s$ 的第 $i$ 项为任意元素，都依然能满足 $cal(B)$。

直觉上来说，判断 $s$ 是否满足 $cal(B)$ 就是把其中的所有的自由变量 $x_i$ 相应替换为 $s_i$，然后用命题演算去判断是否为真。

#definition[
  + 一个公式 $cal(B)$ 对诠释 $M$ 为真，记作 $Vdash_M cal(B)$，指的是 $D$ 中任意序列都能满足 $cal(B)$。
  + $cal(B)$ 对 $M$ 为假指的是没有一个 $D$ 中序列能满足 $cal(B)$
  + 一个诠释 $M$ 称为公式集 $Gamma$ 的一个*模型(model)*指的是 $Gamma$ 中每一个公式都对 $M$ 为真。
]

下列性质很容易验证：
#proposition[
  设 $M$ 是诠释，$cal(B),cal(C)$ 是合式公式，则有
  #enum(numbering: "(I)")[
    - $cal(B)$ 对 $M$ 为假当且仅当 $not cal(B)$ 对 $M$ 为真。
    - $cal(B)$ 对 $M$ 为真当且仅当 $not cal(B)$ 对 $M$ 为假。
  ][
    不能同时有 $class("normal", tack.r.double)_M cal(B)$ 和 $class("normal", tack.r.double)_M not cal(B)$。
  ][
    如果有 $class("normal", tack.r.double)_M cal(B)$ 和 $class("normal", tack.r.double)_M cal(B) -> cal(C)$，
    那么就有 $class("normal", tack.r.double)_M cal(C)$。
  ][
    $cal(B) -> cal(C)$ 对 $M$ 为假当且仅当 $class("normal", tack.r.double)_M cal(B)$ 以及 $class("normal", tack.r.double)_M not cal(C)$。
  ][
    序列 $s$ 满足
    - $cal(B) and cal(C)$ 当且仅当 $s$ 满足 $cal(B)$ 和 $cal(C)$。
    - $cal(B) or cal(C)$ 当且仅当 $s$ 满足 $cal(B)$ 或者 $cal(C)$。
    - $cal(B) <-> cal(C)$ 当且仅当 $s$ 同时满足 $cal(B)$ 和 $cal(C)$ 或者同时不满足它们。
    - $(exists x_i) cal(B)$ 当且仅当有一个 $D$ 中的元素 $c$ 使得序列 $(s_1, dots, s_(i-1), c, s_(i+1),dots)$ 满足 $cal(B)$。
  ][
    $Vdash_M cal(B)$ 当且仅当 $Vdash_M (forall x_i)cal(B)$
  ]
]<诠释的性质>

接下来我们给出公式在语义上为真（而不是语法上可证明）的定义：
#definition[
  + 公式 $cal(B)$ 称为*逻辑有效的(logically valid)*指的是它对每个诠释都为真。
  + $cal(B)$ 称为*可满足的(satisfiable)*指的是存在一个诠释，其中至少有一个序列能满足 $cal(B)$。
  + $cal(B)$ 称为*矛盾的*指的是它对每个诠释都为假，也就是 $not cal(B)$ 是逻辑有效的。
  + 我们称 $cal(B)$ *逻辑推导出(logically imply)* 公式 $cal(C)$，记作 $cal(B) => cal(C)$ 指的是在每个诠释中，每个满足 $cal(B)$ 的序列都满足 $cal(C)$。更一般地，$cal(C)$ 是公式集 $Gamma$ 的逻辑结论指的是在每个诠释中，满足 $Gamma$ 中所有公式的序列也满足 $cal(C)$。
  + $cal(B)$ 和 $cal(C)$ 被称为*逻辑等价*指的是它们互相逻辑推到出对方，记作 $cal(B) <=> cal(C)$。
]


下列结论很容易验证：
+ $cal(B) => cal(C)$ 当且仅当 $cal(B) -> cal(C)$ 是逻辑有效的。
+ $cal(B) <=> cal(C)$ 当且仅当 $cal(B) <-> cal(C)$ 是逻辑有效的。
+ $cal(B) => cal(C)$ 以及 $cal(B)$ 对某个诠释为真，那么 $cal(C)$ 对这个诠释也为真。
+ $cal(C)$ 是公式集 $Gamma$ 的逻辑结论，$Gamma$ 中所有公式对给定诠释为真，则 $cal(C)$ 对这个诠释也为真。

#definition[
  设 $K$ 是一阶语言 $scr(L)$ 上的一个一阶理论。$K$ 的一个*模型*指的是 $scr(L)$ 的一个诠释使得 $K$ 的所有公理为真。
]

参考 @mendelson1997introduction，$K$ 任意定理对它的每个模型都为真。

#example(title: "群公理的模型")[
  诠释域 $D$ 取为整数集 $ZZ$，$=$ 是 $ZZ$ 的 $=$，$dot$ 是 $ZZ$ 里的 $+$，$1$ 取为 $ZZ$ 的 $0$。
  不难验证这个诠释是群公理的一个模型。
]

== 一阶理论的性质
同样，本节基本不会给出任何证明，具体参考 @mendelson1997introduction。同时从本节开始，用理论一词代替一阶理论。

#proposition[
  谓词演算的定理都逻辑有效。
]

#definition(title: "一致性")[
  一个理论被称为*一致的(consistent)*指的是其中不存在公式 $cal(B)$ 使得它和 $not cal(B)$ 都可证明（也就是都是定理）。
]

#note-box[
  考虑到一个公式和它的否定只能有一个对某诠释为真，因此只要一个理论有一个模型，那么这个理论就是一致的。
  因此一个常用的证明一致性的办法是找到模型，这实际上是把一致性问题往底层推。比如欧式几何公理的一致性可以由实数理论来保证。
]


上面的命题能推导出
#proposition[
  谓词演算是一致的。
]

== 带等号的一阶理论<等号公理>
设 $K$ 是一阶理论，且具有谓词 $A_1^2$。用 $t = s$ 来表示 $A_1^2(t,s)$，用 $t eq.not s$ 表示 $not A_1^2(t,s)$。
如果它还带有下列公理：
#enum(start : 6, numbering: it=> [(A#it)])[
  等号的反身性：$(forall x_1) x_1 = x_1$。
][
  等号的替换性：$(forall x)(forall y)x = y -> (cal(B)(x,x) -> cal(B)(x,y))$。
]
这里 $cal(B)(x,y)$ 表示替换部分（可以是也可以不是全部） $cal(B)(x,x)$ 中的占位符 $x$ 为 $y$。

显然前面给出的群理论是带等号的一阶理论。

#proposition[
  在任何带等号的理论中，有如下定理
  + 对任意项有 $t=t$，这是反身性
  + 对任意项 $t,s$ 有 $t=s -> s=t$，这是对称性。
  + 对任意项 $t,s,r$ 有 $t=s -> (s=r -> t=r)$，这是传递性。
]